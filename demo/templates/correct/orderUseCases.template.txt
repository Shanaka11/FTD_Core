import {
  executeTransaction,
  generateId,
  makeCreateModel,
  makeDeleteModel,
  makeReadModel,
  makeUpdateModel,
  TExecuteQuery,
  TGetModelUseCase,
  TRawData,
  validateModel,
} from "@five12days/core";

import { orderSchema, TOrder } from "./order.gen.js";
import {
  makeCreateOrderBaseUseCase,
  makeDeleteOrderBaseUseCase,
  makeReadOrderBaseUseCase,
  makeUpdateOrderBaseUseCase,
  TOrderKey,
} from "./orderBaseUseCases.gen.js";

const validateOrderModel = (data: TRawData) => {
  return validateModel<TOrder>(orderSchema, data);
};

// READ
export const readOrderUseCase_ = async (
  { keys, columns, filter }: TGetModelUseCase<TOrderKey>,
  executeQuery: TExecuteQuery,
) => {
  // Add business logic that should be executed before the core method
  const readOrderBaseUseCase = makeReadOrderBaseUseCase({
    repository: { readModel: makeReadModel(executeQuery) },
  });
  const orders = await readOrderBaseUseCase({
    keys,
    columns,
    filter,
  });
  // Add business logic that should be executed after the core method

  return orders;
};

export const readOrderUseCase = async (data: TGetModelUseCase<TOrderKey>) => {
  const retData = await executeTransaction<
    TGetModelUseCase<TOrderKey>,
    TOrder[]
  >(data, readOrderUseCase_);
  return retData;
};

// CREATE
export const createOrderUseCase_ = async (
  orderData: Partial<TOrder>,
  executeQuery: TExecuteQuery,
) => {
  // Add business logic that should be executed before the core method
  const createOrderBaseUseCase = makeCreateOrderBaseUseCase({
    generateId,
    validateModel: validateOrderModel,
    repository: {
      readModel: makeReadModel(executeQuery),
      createModel: makeCreateModel(executeQuery),
    },
  });

  const createdOrder = await createOrderBaseUseCase(orderData);
  // Add business logic that should be executed after the core method

  return createdOrder;
};

export const createOrderUseCase = async (data: Partial<TOrder>) => {
  const retData = await executeTransaction<Partial<TOrder>, boolean>(
    data,
    createOrderUseCase_,
  );

  return retData;
};

// UPDATE
export const updateOrderUseCase_ = async (
  orderData: TOrder,
  executeQuery: TExecuteQuery,
) => {
  // Add business logic that should be executed before the core method
  const updateOrderBaseUseCase = makeUpdateOrderBaseUseCase({
    generateId,
    validateModel: validateOrderModel,
    repository: {
      readModel: makeReadModel(executeQuery),
      updateModel: makeUpdateModel(executeQuery),
    },
  });

  const updatedOrder = await updateOrderBaseUseCase(orderData);
  // Add business logic that should be executed after the core method

  return updatedOrder;
};

export const updateOrderUseCase = async (data: TOrder) => {
  const retData = await executeTransaction<TOrder, boolean>(
    data,
    updateOrderUseCase_,
  );

  return retData;
};

// DELETE
export const deleteOrderUseCase_ = async (
  orderData: TOrder,
  executeQuery: TExecuteQuery,
) => {
  // Add business logic that should be executed before the core method
  const deleteOrderBaseUseCase = makeDeleteOrderBaseUseCase({
    generateId,
    validateModel: validateOrderModel,
    repository: {
      readModel: makeReadModel(executeQuery),
      deleteModel: makeDeleteModel(executeQuery),
    },
  });

  const deletedOrder = deleteOrderBaseUseCase(orderData);
  // Add business logic that should be executed after the core method

  return deletedOrder;
};

export const deleteOrderUseCase = async (data: TOrder) => {
  const retData = await executeTransaction<TOrder, boolean>(
    data,
    deleteOrderUseCase_,
  );

  return retData;
};
